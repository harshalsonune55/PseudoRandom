# Verilog Encryptor Project

This project implements a simple **8-bit stream cipher** in **Verilog** using a **Linear Feedback Shift Register (LFSR)** as a pseudorandom number generator (PRNG). It includes hardware design modules and a testbench to simulate and verify the encryption and decryption process.

---

## ‚ö†Ô∏è Security Disclaimer

This project is **for educational purposes only**.  
The LFSR-based stream cipher implemented here is **NOT secure** and can be easily broken with modern analysis.  
Do **not** use it for encrypting any real or sensitive information.

---

## üîë How It Works

The project is based on the concept of a **stream cipher**.

1. **Keystream** ‚Äî A ‚Äúrandom‚Äù sequence of bits is generated by the LFSR.  
2. **XOR Operation** ‚Äî The plaintext is combined with this keystream using XOR to produce ciphertext.

Because XOR is its own inverse, the same hardware module can perform both encryption and decryption:

```
Encryption:  Plaintext ‚äï Keystream = Ciphertext
Decryption:  Ciphertext ‚äï Keystream = Plaintext
```

For this to work:
- Both encryptor and decryptor must use the **same seed (key)**.
- They must be **synchronized** (via reset at the same time).

The seed used here is hard-coded as:

```verilog
8'b10101010
```

---

## üìÅ File Structure

All Verilog code is contained in a single file:

```
run_encryption.v
```

This file includes all design and testbench modules.

---

## üß© Design Modules

### 1. `lfsr` (Linear Feedback Shift Register)
- Generates the 8-bit pseudorandom keystream.
- Feedback taps at bits **7, 5, 4, and 3** for a maximal-length sequence.
- Seed (`8'b10101010`) loaded on reset.

### 2. `stream_cipher`
- Performs the XOR operation:
  ```verilog
  data_out = data_in ^ key_in;
  ```

### 3. `message_encryptor`
- Top-level module.
- Instantiates `lfsr` and `stream_cipher` and connects them.

### 4. `dff` & `xor2`
- Helper modules used in the construction of the `lfsr`.

---

## üß™ Test Module

### `tb_encryptor`
- Simulates the complete system.
- Instantiates two `message_encryptor` modules:
  - One as **encryptor**.
  - One as **decryptor**.
- Feeds encryptor output directly into decryptor.
- Generates `clk` and `reset` signals.
- Sends the plaintext `"hello world !"` and prints:

  - Original plaintext  
  - Ciphertext  
  - Decrypted output

---

## ‚ñ∂Ô∏è How to Run the Simulation

### **Prerequisites**
- **Icarus Verilog** (`iverilog`)
- **Terminal** (VS Code terminal, bash, Command Prompt, etc.)

---

### **Steps**

1. **Navigate** to the project directory:
   ```bash
   cd path/to/project
   ```

2. **Compile** the Verilog code:
   ```bash
   iverilog -o my_simulation run_encryption.v
   ```

3. **Run** the simulation:
   ```bash
   vvp my_simulation
   ```

---

## üìä Example Output

```
Time  | Plaintext | Ciphertext | Decrypted
--------------------------------------------
 25ns | 0x68 (h) |   0xcc    |  0x68 (h)
 35ns | 0x65 (e) |   0x11    |  0x65 (e)
 45ns | 0x6c (l) |   0x5d    |  0x6c (l)
 55ns | 0x6c (l) |   0xbf    |  0x6c (l)
 65ns | 0x6f (o) |   0x3f    |  0x6f (o)
 75ns | 0x20 ( ) |   0xaf    |  0x20 ( )
 85ns | 0x77 (w) |   0x0b    |  0x77 (w)
 95ns | 0x6f (o) |   0x5a    |  0x6f (o)
105ns | 0x72 (r) |   0xe0    |  0x72 (r)
115ns | 0x6c (l) |   0xb4    |  0x6c (l)
125ns | 0x64 (d) |   0xe2    |  0x64 (d)
135ns | 0x20 ( ) |   0xb1    |  0x20 ( )
145ns | 0x21 (!) |   0x0e    |  0x21 (!)
155ns | 0x00 ( ) |   0x87    |  0x00 ( )

Simulation Finished.
```
